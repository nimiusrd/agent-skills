# リファクタリングの定義・制約・禁止事項

## 定義

リファクタリングとは、外部仕様（振る舞い）を変更せずに、コードの内部構造を改善する変更である。

## 制約（必ず守ること）

- 既存の機能を変更してはならない
- 新機能を追加してはならない
- 明示的な指示がない限り、公開インターフェースを変更してはならない
- 変更は最小限かつ段階的に行うこと

## 目的

- 可読性の向上
- 複雑性の低減
- 重複の排除
- 責務の明確化

## スコープ

### Level 1（デフォルト）
- 関数内または1ファイル内で完結する変更
- 例：関数分割、変数名変更、ロジック整理

### Level 2（明示指示が必要）
- 複数ファイルにまたがる変更
- 依存関係の整理、責務分離

### Level 3（明示指示が必要）
- アーキテクチャ変更
- レイヤー構造の変更

## 成功条件

以下をすべて満たすこと：

1. 振る舞いが変更されていない
2. コードの理解しやすさが向上している
3. 変更の影響範囲が限定されている
4. 不要な複雑性が減少している

## 振る舞いの検証方法（Gate チェック）

### Gate A（必須条件）
- 既存の自動テストがすべて成功すること。

### Gate B（十分性チェック）
以下を満たすこと：
- 変更対象に関して、重要パスがテストされている
  - 正常系（代表入力）
  - 境界値（空/0/最大長/上限付近）
  - 異常系（例外・エラー条件）
  - 副作用（DB更新・外部I/O・キャッシュなど）

### 判定結果に応じた行動
- Gate A と Gate B を満たす：リファクタリングを実行してよい
- いずれかが未達：**リファクタリングを中止する**
  - 中止時は以下を出力する：
    1. 未達の条件（A/B のどれか）
    2. 根拠（カバレッジ値、未テストの重要パスの具体）
    3. 実行しない理由（仕様保持を客観的に担保できないため）

## 禁止事項（アンチパターン）

以下は禁止する：

- 大規模な書き直し（リライト）
- 過剰な抽象化
- 将来のための設計（YAGNI違反）
- パフォーマンス最適化を混在させる
- 仕様変更を伴う修正
- API変更やデータ構造の変更（明示指示なし）
